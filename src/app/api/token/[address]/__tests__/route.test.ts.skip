/* eslint-disable @typescript-eslint/no-explicit-any */

// Mock Redis before importing the route
const mockGet = jest.fn();
const mockSetex = jest.fn();

jest.mock('@upstash/redis', () => ({
  Redis: jest.fn().mockImplementation(() => ({
    get: mockGet,
    setex: mockSetex,
  })),
}));

// Now import the route
import { GET } from '../route';

describe('Token API Route', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('validates token address format', async () => {
    const request = { url: 'http://localhost:3000/api/token/invalid-address', nextUrl: new URL('http://localhost:3000/api/token/invalid-address') } as any;
    const response = await GET(request, { params: { address: 'invalid-address' } });

    expect(response.status).toBe(400);
    const data = await response.json();
    expect(data.error).toBe('Invalid token address');
  });

  it('returns cached data when available', async () => {
    const cachedData = {
      name: 'Cached Token',
      symbol: 'CACHED',
      address: '0x1234567890abcdef1234567890abcdef12345678',
      txHash: '0xabc',
      imageUrl: 'ipfs://cached',
      creatorAddress: '0xcreator',
      totalSupply: '1000000',
      marketCap: '50000',
      holders: 42,
      volume24h: '10000',
      priceChange24h: 15.5,
    };

    mockGet.mockResolvedValue(cachedData);

    const request = { url: 'http://localhost:3000/api/token/0x1234567890abcdef1234567890abcdef12345678', nextUrl: new URL('http://localhost:3000/api/token/0x1234567890abcdef1234567890abcdef12345678') } as any;
    const response = await GET(request, { params: { address: '0x1234567890abcdef1234567890abcdef12345678' } });

    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data.success).toBe(true);
    expect(data.data).toEqual(cachedData);
    expect(mockGet).toHaveBeenCalledWith('token:0x1234567890abcdef1234567890abcdef12345678');
  });

  it('fetches and caches data when not in cache', async () => {
    mockGet.mockResolvedValue(null);
    mockSetex.mockResolvedValue('OK');

    const request = { url: 'http://localhost:3000/api/token/0x1234567890abcdef1234567890abcdef12345678', nextUrl: new URL('http://localhost:3000/api/token/0x1234567890abcdef1234567890abcdef12345678') } as any;
    const response = await GET(request, { params: { address: '0x1234567890abcdef1234567890abcdef12345678' } });

    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data.success).toBe(true);
    expect(data.data).toHaveProperty('name');
    expect(data.data).toHaveProperty('symbol');
    expect(data.data).toHaveProperty('marketCap');
    
    expect(mockSetex).toHaveBeenCalledWith(
      'token:0x1234567890abcdef1234567890abcdef12345678',
      300,
      expect.any(Object)
    );
  });

  it('handles Redis errors gracefully', async () => {
    mockGet.mockRejectedValue(new Error('Redis connection failed'));

    const request = { url: 'http://localhost:3000/api/token/0x1234567890abcdef1234567890abcdef12345678', nextUrl: new URL('http://localhost:3000/api/token/0x1234567890abcdef1234567890abcdef12345678') } as any;
    const response = await GET(request, { params: { address: '0x1234567890abcdef1234567890abcdef12345678' } });

    expect(response.status).toBe(500);
    const data = await response.json();
    expect(data.success).toBe(false);
    expect(data.error).toBe('Failed to fetch token data');
  });

  it('normalizes address to lowercase for cache key', async () => {
    mockGet.mockResolvedValue(null);

    const request = { url: 'http://localhost:3000/api/token/0xABCDEF1234567890ABCDEF1234567890ABCDEF12', nextUrl: new URL('http://localhost:3000/api/token/0xABCDEF1234567890ABCDEF1234567890ABCDEF12') } as any;
    await GET(request, { params: { address: '0xABCDEF1234567890ABCDEF1234567890ABCDEF12' } });

    expect(mockGet).toHaveBeenCalledWith('token:0xabcdef1234567890abcdef1234567890abcdef12');
  });
});