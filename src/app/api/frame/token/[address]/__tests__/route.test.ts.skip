/* eslint-disable @typescript-eslint/no-explicit-any */

// Mock fetch
global.fetch = jest.fn();

jest.mock('@/lib/ipfs', () => ({
  getIpfsUrl: jest.fn((url) => url?.replace('ipfs://', 'https://ipfs.io/ipfs/')),
}));

// Import after mocks
import { GET } from '../route';

describe('Frame Token API Route', () => {
  const mockTokenData = {
    name: 'Test Token',
    symbol: 'TEST',
    address: '0x1234567890abcdef',
    imageUrl: 'ipfs://test-image',
    marketCap: '50000',
    holders: 42,
    volume24h: '10000',
    priceChange24h: 15.5,
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('returns frame metadata HTML for valid token', async () => {
    (fetch as jest.Mock).mockResolvedValue({
      ok: true,
      status: 200,
      json: async () => ({ success: true, data: mockTokenData }),
    });

    const request = {
      url: 'http://localhost:3000/api/frame/token/0x1234567890abcdef',
      nextUrl: {
        origin: 'http://localhost:3000',
        searchParams: new URLSearchParams(),
      },
    } as any;
    
    const response = await GET(request, { params: { address: '0x1234567890abcdef' } });

    expect(response.status).toBe(200);
    expect(response.headers.get('content-type')).toBe('text/html');

    const html = await response.text();
    
    // Check for required frame meta tags
    expect(html).toContain('<meta property="fc:frame" content="vNext" />');
    expect(html).toContain(`<meta property="og:title" content="${mockTokenData.name} ($${mockTokenData.symbol})" />`);
    expect(html).toContain('<meta property="fc:frame:image" content="https://ipfs.io/ipfs/test-image" />');
    
    // Check for action buttons
    expect(html).toContain('<meta property="fc:frame:button:1" content="View Token" />');
    expect(html).toContain('<meta property="fc:frame:button:1:action" content="link" />');
    expect(html).toContain(`<meta property="fc:frame:button:1:target" content="http://localhost:3000/token/${mockTokenData.address}" />`);
    
    expect(html).toContain('<meta property="fc:frame:button:2" content="Trade on DEX" />');
    expect(html).toContain('<meta property="fc:frame:button:2:action" content="link" />');
  });

  it('includes token metrics in description', async () => {
    (fetch as jest.Mock).mockResolvedValue({
      ok: true,
      status: 200,
      json: async () => ({ success: true, data: mockTokenData }),
    });

    const request = {
      url: 'http://localhost:3000/api/frame/token/0x1234567890abcdef',
      nextUrl: {
        origin: 'http://localhost:3000',
        searchParams: new URLSearchParams(),
      },
    } as any;
    
    const response = await GET(request, { params: { address: '0x1234567890abcdef' } });

    const html = await response.text();
    
    expect(html).toContain('Market Cap: $50,000');
    expect(html).toContain('Holders: 42');
    expect(html).toContain('24h Volume: $10,000');
  });

  it('handles missing token data gracefully', async () => {
    (fetch as jest.Mock).mockResolvedValue({
      ok: false,
      status: 404,
      json: async () => ({ success: false, error: 'Token not found' }),
    });

    const request = {
      url: 'http://localhost:3000/api/frame/token/0x1234567890abcdef',
      nextUrl: {
        origin: 'http://localhost:3000',
        searchParams: new URLSearchParams(),
      },
    } as any;
    
    const response = await GET(request, { params: { address: '0x1234567890abcdef' } });

    expect(response.status).toBe(404);
    
    const data = await response.json();
    expect(data.error).toBe('Token not found');
  });

  it('validates token address format', async () => {
    const request = {
      url: 'http://localhost:3000/api/frame/token/invalid-address',
      nextUrl: {
        origin: 'http://localhost:3000',
        searchParams: new URLSearchParams(),
      },
    } as any;
    
    const response = await GET(request, { params: { address: 'invalid-address' } });

    expect(response.status).toBe(400);
    
    const data = await response.json();
    expect(data.error).toBe('Invalid token address');
  });

  it('caches successful responses', async () => {
    (fetch as jest.Mock).mockResolvedValue({
      ok: true,
      status: 200,
      json: async () => ({ success: true, data: mockTokenData }),
    });

    const request = {
      url: 'http://localhost:3000/api/frame/token/0x1234567890abcdef',
      nextUrl: {
        origin: 'http://localhost:3000',
        searchParams: new URLSearchParams(),
      },
    } as any;
    
    const response = await GET(request, { params: { address: '0x1234567890abcdef' } });

    expect(response.headers.get('cache-control')).toBe('public, max-age=60, stale-while-revalidate=300');
  });

  it('includes share functionality in frame', async () => {
    (fetch as jest.Mock).mockResolvedValue({
      ok: true,
      status: 200,
      json: async () => ({ success: true, data: mockTokenData }),
    });

    const request = {
      url: 'http://localhost:3000/api/frame/token/0x1234567890abcdef',
      nextUrl: {
        origin: 'http://localhost:3000',
        searchParams: new URLSearchParams(),
      },
    } as any;
    
    const response = await GET(request, { params: { address: '0x1234567890abcdef' } });

    const html = await response.text();
    
    expect(html).toContain('<meta property="fc:frame:button:3" content="Share" />');
    expect(html).toContain('<meta property="fc:frame:button:3:action" content="link" />');
    expect(html).toContain('<meta property="fc:frame:button:3:target"');
  });

  it('handles network errors', async () => {
    (fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

    const request = {
      url: 'http://localhost:3000/api/frame/token/0x1234567890abcdef',
      nextUrl: {
        origin: 'http://localhost:3000',
        searchParams: new URLSearchParams(),
      },
    } as any;
    
    const response = await GET(request, { params: { address: '0x1234567890abcdef' } });

    expect(response.status).toBe(500);
    
    const data = await response.json();
    expect(data.error).toBe('Failed to fetch token data');
  });

  it('includes proper OpenGraph tags', async () => {
    (fetch as jest.Mock).mockResolvedValue({
      ok: true,
      status: 200,
      json: async () => ({ success: true, data: mockTokenData }),
    });

    const request = {
      url: 'http://localhost:3000/api/frame/token/0x1234567890abcdef',
      nextUrl: {
        origin: 'http://localhost:3000',
        searchParams: new URLSearchParams(),
      },
    } as any;
    
    const response = await GET(request, { params: { address: '0x1234567890abcdef' } });

    const html = await response.text();
    
    expect(html).toContain('<meta property="og:type" content="website" />');
    expect(html).toContain('<meta property="og:image" content="https://ipfs.io/ipfs/test-image" />');
    expect(html).toContain('<meta property="og:url"');
  });

  it('supports different frame versions via query parameter', async () => {
    (fetch as jest.Mock).mockResolvedValue({
      ok: true,
      status: 200,
      json: async () => ({ success: true, data: mockTokenData }),
    });

    const searchParams = new URLSearchParams('version=v2');
    const request = {
      url: 'http://localhost:3000/api/frame/token/0x1234567890abcdef?version=v2',
      nextUrl: {
        origin: 'http://localhost:3000',
        searchParams: searchParams,
      },
    } as any;
    
    const response = await GET(request, { params: { address: '0x1234567890abcdef' } });

    const html = await response.text();
    
    // Should include enhanced features for v2
    expect(html).toContain('<meta property="fc:frame:version" content="v2" />');
  });
});